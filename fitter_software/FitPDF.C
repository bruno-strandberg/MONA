#include "Riostream.h" 

#include "FitPDF.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 
#include "NMHUtils.h"
#include <stdexcept>

ClassImp(FitPDF); 

/** Copy constructor.

    \param other   Other instance of FitPDF
    \param name    Name of the copy
 */
FitPDF::FitPDF(const FitPDF& other, const char* name) : RooAbsPdf(other, name) { 
  
  // get the pointer to the fit utility and the response
  fFitUtil  = other.fFitUtil;
  fResponse = other.fResponse;

  // re-create the proxy map
  for (auto &p: other.fProxies) {    
    RooRealProxy *po = p.second;
    TString name     = p.first;
    fProxies.insert ( std::make_pair( name, new RooRealProxy(name, this, *po) ) );
  }
        
}

//*******************************************************************************

/** Constructor.

    The class takes a pointer to a pre-initialised `FitUtil` class and a pre-initialised `DetResponse` class as arguments. The latter specifies the event selection the pdf is used to fit, whereas the former is the actual worker class where all the calculations are performed.

    \param name   Name of the pdf
    \param title  Title of the pdf
    \param futil  Pointer to the `FitUtil` class
    \param resp   Pointer to a `DetResponse` instance

 */
FitPDF::FitPDF(const char *name, const char *title, FitUtil *futil, DetResponse *resp) : RooAbsPdf(name, title) {

  // set the pointers
  if (futil == NULL ) {
    throw std::invalid_argument("ERROR! FitPDF::FitPDF() null pointer to FitUtil class");
  }

  if (resp == NULL) {
    throw std::invalid_argument("ERROR! FitPDF::FitPDF() null pointer to DetResponse class");
  }
  
  fFitUtil  = futil;
  fResponse = resp;

  if ( !NMHUtils::BinsMatch( fFitUtil->GetBinningHist(), fResponse->GetHist3D() ) ) {
    throw std::invalid_argument("ERROR! FitPDF::FitPDF() FitUtil and DetResponse use different binning.");
  }
  
  // create a list of the parameters for iteration and create proxies
  RooArgList pars( fFitUtil->GetSet() );

  for (Int_t i = 0; i < pars.getSize(); i++) {
    RooRealVar* v = (RooRealVar*)pars.at(i);
    TString name = v->GetName();
    fProxies.insert( std::make_pair( name, new RooRealProxy(name, name, this, *v) ) );
  }
  
}

//*******************************************************************************

/** This method is called by the minimiser to get the expected number of events in a bin 

    This function is a wrapper around `FitUtil::PdfEvaluate`, all the work is done in `FitUtil` class.

    \return Expected event density in a reco bin.
*/
Double_t FitPDF::evaluate() const { 
  
  return fFitUtil->PdfEvaluate(fProxies, fResponse).first;

} 

//*******************************************************************************

/** This funcion helps RooFit to decide which integration technique to use - skeleton was autogenerated.
    
    See `RooFit` user manual and documentation for further details.
*/
Int_t FitPDF::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const {

  // this tells RooFit that integration over E, ct and by ( returned by GetObs() ) can be done "analytically"
  if ( matchArgs( allVars, analVars, fFitUtil->GetObs() ) ) { return I_E_CT_BY; }
  else                                                      { return (Int_t)I_NUMERIC; }

}

//*******************************************************************************

/** Depending on the code returned by `getAnalyticalIntegral` return the integral - skeleton was autogenerated.

    This function and `getAnalyticalIntegral` make it possible to use `RooFit` for NMO analysis. `RooFit` needs to know the integral of the fit model (returned by `FitPDF::evaluate()`) over the observables \f$ (E_{\rm reco}, cos\theta_{\rm reco}, by_{\rm reco})  \f$, because it works with probability density functions which need to be normalised to 1. Without telling `RooFit` how to integrate, it tries to perform a numberic integration and chokes completely, because this is over 3 dimensions and needs to be performed each time the oscillation parameters change.

    Now, in this special case of a <B>binned analysis</B>, the integral boils down to the integral of the number of events in the expectation value histogram. This can be understood as follows. `FitPDF::evaluate()` returns the un-normalized event density within each bin, i.e. \f$ f(x) = binContent/binWidth \f$. `RooFit` needs to integrate this. If it is approximated that \f$ \int f(x)dx \approx \sum f(x=binCenter) * binWidth \f$, the integral becomes \f$ \sum binContent \f$, hence equivalent to the number of events in the expectation value histogram.
    
    \param code      Code returned by `getAnalyticalIntegral` to determine integration technique
    \param rangeName Name of the fit range (dummy for now)
    \return          Integral of the pdf over observables.

*/
Double_t FitPDF::analyticalIntegral(Int_t code, const char* rangeName) const {

  Double_t integral = 0.;
  
  if ( code == I_E_CT_BY ) {
    auto expct = fFitUtil->PdfExpectation(fProxies, fResponse, rangeName);
    integral = expct->Integral();
    delete expct;
  }
  else {
    integral = 0.;
  }

  return integral;
  
}

//*******************************************************************************

/** Implementation of this function allows the class to be used with TF1/TF2/TF3

    \param x  Observable array (reconstructed E, cos-theta, bjorken-y)
    \param p  Parameter array (sinsqth12, 13, 23, delta-cp, dm21, dm31)
    \return   Number of events in the reco bin
    
 */
double FitPDF::operator()(double *x, double *p) {

  Double_t E  = x[0];
  Double_t ct = x[1];
  Double_t by = x[2];

  Double_t sinsqth12  = p[0];
  Double_t sinsqth13  = p[1];
  Double_t sinsqth23  = p[2];
  Double_t dcp        = p[3];
  Double_t dm21       = p[4];
  Double_t dm31       = p[5];

  return fFitUtil->RecoEvts(fResponse, E, ct, by, sinsqth12, sinsqth13, sinsqth23, dcp, dm21, dm31).first;
  
}

//*******************************************************************************

/** Function to create a TH3D that represents a pseudo-experiment

    TO-BE-IMPLEMENTED

*/
TH3D* FitPDF::SimplePseudoExp() {

  TH3D* dummy = NULL;
  
  /*
    To be implemented. GetExpValHist() and perform poisson smearing in each bin.
    Perhaps take the statistical error of the expectation into account when doing the smearing
   */

  return dummy;
  
}
