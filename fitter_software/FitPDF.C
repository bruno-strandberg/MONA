#include "Riostream.h" 

#include "FitPDF.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 
#include "NMHUtils.h"
#include <stdexcept>

ClassImp(FitPDF); 

/** Copy constructor.

    \param other   Other instance of FitPDF
    \param name    Name of the copy
 */
FitPDF::FitPDF(const FitPDF& other, const char* name) : RooAbsPdf(other, name) { 
  
  // get the pointer to the fit utility and the response
  fFitUtil  = other.fFitUtil;
  fResponse = other.fResponse;
  fRand     = other.fRand;
  fExtMode  = other.fExtMode;

  // re-create the proxy map
  for (auto &p: other.fProxies) {    
    RooRealProxy *po = p.second;
    TString name     = p.first;
    fProxies.insert ( std::make_pair( name, new RooRealProxy(name, this, *po) ) );
  }
        
}

//*******************************************************************************

/** Constructor.

    The class takes a pointer to a pre-initialised `FitUtil` class and a pre-initialised response class as arguments. The response class needs to inherit from `AbsResponse`. The response specifies the event selection the pdf is used to fit, whereas the `FitUtil` is the actual worker class where all the calculations are performed.

    \param name      Name of the pdf
    \param title     Title of the pdf
    \param futil     Pointer to the `FitUtil` class
    \param resp      Pointer to a response instance

 */
FitPDF::FitPDF(const char *name, const char *title, FitUtil *futil, AbsResponse *resp) :
  RooAbsPdf(name, title) {

  // set the pointers
  if (futil == NULL ) {
    throw std::invalid_argument("ERROR! FitPDF::FitPDF() null pointer to FitUtil class");
  }

  if (resp == NULL) {
    throw std::invalid_argument("ERROR! FitPDF::FitPDF() null pointer to response class");
  }
  
  fFitUtil  = futil;
  fResponse = resp;
  fExtMode  = RooAbsPdf::CanNotBeExtended;
  
  if ( !NMHUtils::BinsMatch( fFitUtil->GetBinningHistReco(), fResponse->GetHist3DReco() ) ||
       !NMHUtils::BinsMatch( fFitUtil->GetBinningHistTrue(), fResponse->GetHist3DTrue() ) ) {
    throw std::invalid_argument("ERROR! FitPDF::FitPDF() FitUtil and Response use different binning.");
  }
    
  // create a list of the parameters for iteration and create proxies
  RooArgList pars( fFitUtil->GetSet() );

  for (Int_t i = 0; i < pars.getSize(); i++) {
    RooRealVar* v = (RooRealVar*)pars.at(i);
    TString name = v->GetName();
    fProxies.insert( std::make_pair( name, new RooRealProxy(name, name, this, *v) ) );
  }
  
}

//*******************************************************************************

/** This method is called by the minimiser to get the expected number of events in a bin 

    This function is a wrapper around `FitUtil::RecoEvts`, all the work is done in `FitUtil` class.

    \return Expected event density in a reco bin.
*/
Double_t FitPDF::evaluate() const { 

  Double_t E_reco  = *( fProxies.at( fFitUtil->GetEobs() ->GetName() ) );
  Double_t Ct_reco = *( fProxies.at( fFitUtil->GetCTobs()->GetName() ) );
  Double_t By_reco = *( fProxies.at( fFitUtil->GetBYobs()->GetName() ) );

  Double_t reco_evt_density = fFitUtil->RecoEvts(E_reco, Ct_reco, By_reco, fResponse, fProxies).first;

  if ( reco_evt_density < 0. ) {
    cout << "NOTICE FitPDF::evaluate() parameter values at error:" << endl;
    for (auto kv: fProxies) {cout << "Parameter: " << kv.first << "\tValue: " << (Double_t)(*kv.second) << endl;}
    throw std::logic_error("ERROR! FitPDF::evaluate() has received a negative event density from the (overloaded) RecoEvts function. This is not physical and indicates an issue in the (re-)implementation of the virtual functions FitUtil::RecoEvts and FitUtil::TrueEvts.");
  }
  else if ( reco_evt_density == 0.0 ) {
    cout << "NOTICE FitPDF::evaluate() has received 0 event-density from (overloaded) FitUtil::RecoEvts(); returning std::numeric_limits<double>::min() to avoid potential infinity in likelihood evaluation if the fitted bin content is > 0" << endl;
    reco_evt_density = std::numeric_limits<double>::min();
  }

  return reco_evt_density;

} 

//*******************************************************************************

/** This funcion helps RooFit to decide which integration technique to use - skeleton was autogenerated.
    
    See `RooFit` user manual and documentation for further details.
*/
Int_t FitPDF::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const {

  // this tells RooFit that integration over E, ct and by ( returned by GetObs() ) can be done "analytically"
  if ( matchArgs( allVars, analVars, fFitUtil->GetObs() ) ) { return I_E_CT_BY; }
  else                                                      { return (Int_t)I_NUMERIC; }

}

//*******************************************************************************

/** Depending on the code returned by `getAnalyticalIntegral` return the integral - skeleton was autogenerated.

    This function and `getAnalyticalIntegral` make it possible to use `RooFit` for NMO analysis. `RooFit` needs to know the integral of the fit model (returned by `FitPDF::evaluate()`) over the observables \f$ (E_{\rm reco}, cos\theta_{\rm reco}, by_{\rm reco})  \f$, because it works with probability density functions which need to be normalised to 1. Without telling `RooFit` how to integrate, it tries to perform a numberic integration and chokes completely, because this is over 3 dimensions and needs to be performed each time the oscillation parameters change.

    Now, in this special case of a <B>binned analysis</B>, the integral boils down to the integral of the number of events in the expectation value histogram. This can be understood as follows. `FitPDF::evaluate()` returns the un-normalized event density within each bin, i.e. \f$ f(x) = binContent/binWidth \f$. `RooFit` needs to integrate this. If it is approximated that \f$ \int f(x)dx \approx \sum f(x=binCenter) * binWidth \f$, the integral becomes \f$ \sum binContent \f$, hence equivalent to the number of events in the expectation value histogram.
    
    \param code      Code returned by `getAnalyticalIntegral` to determine integration technique
    \param rangeName Range string as used in `RooFit`, it will apply the defined rangeName to the E/Ct/By variables. If the range does not  exists, the default ranges are used.
    \return          Integral of the pdf over observables.

*/
Double_t FitPDF::analyticalIntegral(Int_t code, const char* rangeName) const {

  Double_t integral = 0.;
  
  if ( code == I_E_CT_BY ) {
    auto expct = GetExpValHist(rangeName);
    integral = expct->Integral();
    delete expct;
  }
  else {
    integral = 0.;
  }

  return integral;
  
}

//*******************************************************************************

/** Implementation of this function allows the class to be used with TF1/TF2/TF3

    This is here for the test application `tests/fitting/FitPseudoExperiment.C`, which compares the fit results between `ROOT` and `RooFit`.

    \param x  Observable array (reconstructed E, cos-theta, bjorken-y)
    \param p  Parameter array (sinsqth12, 13, 23, delta-cp, dm21, dm31)
    \return   Number of events in the reco bin
    
 */
double FitPDF::operator()(double *x, double *p) {

  // set `RooFit` parameters to the values from the arguments
  fFitUtil->GetVar("SinsqTh12")->setVal( p[0] );
  fFitUtil->GetVar("SinsqTh13")->setVal( p[1] );
  fFitUtil->GetVar("SinsqTh23")->setVal( p[2] );
  fFitUtil->GetVar("dcp")      ->setVal( p[3] );
  fFitUtil->GetVar("Dm21")     ->setVal( p[4] );
  fFitUtil->GetVar("Dm31")     ->setVal( p[5] );

  // calculate the bin width to conver the event density to number of events
  TH3D *hb = fResponse->GetHist3DReco();

  Double_t e_w  = hb->GetXaxis()->GetBinWidth( hb->GetXaxis()->FindBin(x[0]) );
  Double_t ct_w = hb->GetYaxis()->GetBinWidth( hb->GetYaxis()->FindBin(x[1]) );
  Double_t by_w = hb->GetZaxis()->GetBinWidth( hb->GetZaxis()->FindBin(x[2]) );
  Double_t bw = e_w * ct_w * by_w;
  
  return fFitUtil->RecoEvts(x[0], x[1], x[2], fResponse, fProxies).first * bw;
  
}

//*******************************************************************************

/** Function that returns a pointer to a TH3D that represents a pseudo-experiment.

    The function Poisson-smears the the expectation value in each bin. If the expectation has a statistical uncertainty associated with it and stored in the bin error (as is the case in the return value of `FitUtil::Expectation`), the statistical uncertainty of the expectation value can be taken into account.

    \param nametitle      string used as a name and a title for the created TH3D histogram
    \param IncludeStatErr account for the statistical uncertainty of the expectation in smearing
    \param rangeName      Char array with `RooFit` observable ranges
    \return               Pointer to a TH3D with pseudoexperiment data. NB! these histograms are created on the stack; it is the responsibility of the user to delete the TH3D hists pointed to by the return value.

*/
TH3D* FitPDF::SimplePseudoExp(TString nametitle, Bool_t IncludeStatErr, const char* rangeName) {

  // get the histogram with expectation values
  TH3D* expectation = GetExpValHist(rangeName);

  // create a histogram where the experiment is stored
  TH3D* experiment  = (TH3D*)expectation->Clone(nametitle);
  experiment->SetNameTitle(nametitle, nametitle);
  experiment->SetDirectory(0);
  experiment->Reset();

  // loop over bins
  for (Int_t xbin = 1; xbin <= expectation->GetXaxis()->GetNbins(); xbin++) {
    for (Int_t ybin = 1; ybin <= expectation->GetYaxis()->GetNbins(); ybin++) {
      for (Int_t zbin = 1; zbin <= expectation->GetZaxis()->GetNbins(); zbin++) {

	// get bin content (expected nr of events) and bin error (statistical error on expectation)
	Double_t bc = expectation->GetBinContent(xbin, ybin, zbin);
	Double_t be = expectation->GetBinError(xbin, ybin, zbin);
	
	// if stat err taken into account, smear the expectation value by the statistical error
	Double_t expectation = bc;
	if ( IncludeStatErr ) expectation = fRand.Gaus(bc, be);
	
	// now poisson smear the expectation value to arrive at a "measured" value in the given bin
	Double_t measured = fRand.PoissonD( expectation );
	experiment->SetBinContent(xbin, ybin, zbin, measured);

      }
    }
  }
  
  return experiment;
  
}


//*******************************************************************************

/** Function that returns a pointer to a TH3D containing the relative errors on 
    the expectation value histogram `FitPDF::GetExpValHist`.

    The histogram which is pointed to is created on the heap and it is the user's responsibility to delete the object.

    \param name     Range string as used in `RooFit`, it will apply the defined rangeName to the E/Ct/By variables. If the range does not exists, the default ranges are used.
    \return         Pointer to a TH3D containing the relative errors for GetExpValHist.

*/
TH3D* FitPDF::GetExpValErrHist(const char* name) {

  TH3D* expvalhist = GetExpValHist(name);

  TH3D* errvalhist = (TH3D*)expvalhist->Clone();
  errvalhist->SetNameTitle( expvalhist->GetName() + TString("_err"), expvalhist->GetTitle() + TString("_err") );
  errvalhist->SetDirectory(0);
  errvalhist->Reset();

  for (Int_t xbin = 1; xbin <= expvalhist->GetXaxis()->GetNbins(); xbin++) {
    for (Int_t ybin = 1; ybin <= expvalhist->GetYaxis()->GetNbins(); ybin++) {
      for (Int_t zbin = 1; zbin <= expvalhist->GetZaxis()->GetNbins(); zbin++) {

        // get bin content (expected nr of events) and bin error (statistical error on expectation)
        Double_t bincontent = expvalhist->GetBinContent(xbin, ybin, zbin);
        Double_t binerror   = expvalhist->GetBinError(xbin, ybin, zbin);

        if (bincontent != 0) {
          errvalhist->SetBinContent(xbin, ybin, zbin, binerror / bincontent);
        }
        else {
          errvalhist->SetBinContent(xbin, ybin, zbin, 0);
        }
      }
    }
  }

  delete expvalhist;

  return errvalhist;
}
